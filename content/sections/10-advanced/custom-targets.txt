=== METADATA ===
title: Creating Custom Targets
description: How to implement a new render target for iLoveReact
category: Advanced
platforms: love2d, web, terminal, cc, nvim, hs, awesome
keywords: custom target, IBridge, painter, transport, new platform, extending
related: transport, painter, reconciler, lua-runtime
difficulty: advanced

=== OVERVIEW ===
iLoveReact's architecture is designed for target extensibility. To add a new render
target, you need three things: a transport implementation (IBridge), a painter module,
and an entry point that wires them together with the React reconciler. The existing
targets serve as reference implementations for different transport types (QuickJS FFI,
Module.FS, WebSocket, stdio) and painter strategies (pixel, character grid).

=== API / SYNTAX ===
IBridge Interface (must implement all methods):
  send(type: string, payload?: any): void
  flush(): void
  subscribe(type: string, fn: Listener): Unsubscribe
  rpc<T>(method: string, args?: any, timeoutMs?: number): Promise<T>
  setState(key: string, value: any): void
  isReady(): boolean
  onReady(callback: () => void): void
  destroy(): void

=== EXAMPLES ===
Example 1: Steps to Create a New Target
---
1. Create a new package: packages/mytarget/

2. Implement IBridge for your transport:

   // packages/mytarget/src/MyBridge.ts
   import type { IBridge, Listener, Unsubscribe } from '@ilovereact/core';

   export class MyBridge implements IBridge {
     private listeners = new Map<string, Set<Listener>>();
     private outbox: any[] = [];
     private ready = false;

     send(type: string, payload?: any): void {
       this.outbox.push({ type, payload });
     }

     flush(): void {
       // Send this.outbox to your target runtime
       // Clear the outbox after sending
       this.outbox = [];
     }

     subscribe(type: string, fn: Listener): Unsubscribe {
       if (!this.listeners.has(type)) {
         this.listeners.set(type, new Set());
       }
       this.listeners.get(type)!.add(fn);
       return () => this.listeners.get(type)?.delete(fn);
     }

     rpc<T>(method: string, args?: any, timeoutMs?: number): Promise<T> {
       // Send RPC request, await response via subscribe
       return new Promise((resolve, reject) => { /* ... */ });
     }

     setState(key: string, value: any): void {
       this.send(`state:${key}`, value);
     }

     isReady(): boolean { return this.ready; }
     onReady(cb: () => void): void { if (this.ready) cb(); }
     destroy(): void { /* cleanup */ }
   }

3. Create a painter module (renders nodes to your platform):

   // packages/mytarget/src/painter.ts
   export function paint(root: LayoutNode): void {
     // Walk the tree, read computed rects and styles,
     // issue draw calls for your platform
   }

4. Create an entry point:

   // packages/mytarget/src/index.ts
   import { createRoot, render } from '@ilovereact/native';
   import { BridgeProvider, RendererProvider } from '@ilovereact/core';
   import { MyBridge } from './MyBridge';

   export function createMyApp() {
     const bridge = new MyBridge();
     const root = createRoot();

     return {
       render(element: ReactNode) {
         root.render(
           <BridgeProvider bridge={bridge}>
             <RendererProvider mode="native">
               {element}
             </RendererProvider>
           </BridgeProvider>
         );
       },
       stop() { root.unmount(); bridge.destroy(); },
       bridge,
     };
   }

5. Add esbuild configuration in package.json or build script:
   - Choose --format based on your runtime (iife for embedded, esm for Node.js)
   - Add --external for any native modules
---
Platforms: All

Example 2: Reference Implementations
---
Study these existing targets for different patterns:

  @ilovereact/terminal  - Node.js ESM, built-in transport, character grid painter
  @ilovereact/cc        - Node.js ESM, WebSocket transport, 16-color grid painter
  @ilovereact/nvim      - Node.js ESM, stdio transport, floating window painter
  @ilovereact/hs        - Node.js ESM, WebSocket transport, pixel canvas painter
  @ilovereact/awesome   - Node.js ESM, stdio transport, Cairo/Pango painter
  @ilovereact/web       - Browser ESM, Module.FS transport, CSS flexbox "painter"
  @ilovereact/native    - IIFE, QuickJS FFI transport, Lua pixel painter
---
Platforms: All

=== CRITICAL RULES ===
- Your IBridge implementation MUST implement all methods. Hooks depend on
  subscribe, send, rpc, setState, isReady, and onReady.
- Event handlers stay on the JS side. Only the handler's existence is
  communicated to the target runtime (so it knows to dispatch events back).
- The reconciler is shared. You should not need to modify it for a new target.
- Use @ilovereact/grid for character-grid targets. It provides the shared
  layout engine that maps flexbox to character cells.

=== SEE ALSO ===
- 02-architecture/transport.txt - Transport layer details
- 02-architecture/painter.txt - Painter implementation patterns
- 02-architecture/reconciler.txt - The shared reconciler
