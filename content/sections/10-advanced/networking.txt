=== METADATA ===
title: Networking (HTTP & WebSockets)
description: Making HTTP requests and managing WebSocket connections with proxy support
category: Advanced
platforms: love2d
keywords: http, websocket, network, fetch, proxy, socks5, async, thread
related: tor, lua-runtime
difficulty: intermediate

=== OVERVIEW ===

iLoveReact provides two networking layers: HTTP (via http.lua) for one-off requests,
and WebSocket (via network.lua) for persistent connections. Both support proxying
through HTTP proxies or SOCKS5 (useful for Tor). HTTP uses love.thread for async
non-blocking requests. WebSockets use pure Lua with automatic reconnection.

**For multiplayer games:** Use WebSockets (network.lua) for persistent player connections.
WebSockets automatically reconnect on disconnect and maintain state. Perfect for
real-time multiplayer where players need low-latency communication.

**Two multiplayer patterns:**

1. **Host-Client Model** — one player hosts (server.listen()), others join (connect())
   Use this when one player is "hosting" the game world.

2. **Peer-to-Peer** — players connect directly to each other
   More complex but lower latency; useful for 2-player games.

**Tor Integration:** WebSockets automatically tunnel through Tor (.onion addresses).
See tor.txt for hosting hidden services and anonymous multiplayer.

All networking happens on the Lua side and communicates with JavaScript via the bridge.

=== COMMON PATTERNS ===

**HTTP Requests:**
The http module manages a pool of worker threads. Each request is fire-and-forget;
responses are polled each frame. Useful for API calls, file downloads, webhooks.

**WebSocket Connections (Persistent):**
The network module manages multiple open connections by ID. Each connection supports
auto-reconnect with exponential backoff. Useful for:
- Real-time multiplayer games
- Live chat / messaging
- Remote shells / terminals
- Live data feeds
- Persistent bidirectional communication

**WebSocket Server (Host Mode):**
One player can host a server that other players join. network.listen() starts a
server, network.broadcast() sends to all clients, and events notify of connects/
messages/disconnects.

**Multiplayer Patterns:**

1. **Host-Client** (typical for games):
   - Host player: network.listen("game", 8000) → broadcasts game state
   - Client players: network.connect(N, "ws://host:8000/game") → receives state
   - Simple, one source of truth (the host)

2. **Peer-to-Peer** (advanced):
   - Each player runs both client and server
   - Player A connects to B, B connects to A
   - Share state bidirectionally
   - More complex but lower latency

3. **Central Relay** (recommended for 4+ players):
   - Dedicated server (can be Tor hidden service)
   - Players connect to server
   - Server broadcasts to all
   - Single source of truth

4. **Tor-Based** (for p2p without port forwarding):
   - Enable Tor hidden service (tor.start())
   - Host a server on that .onion address
   - Players connect to .onion address
   - Tor handles NAT/firewall traversal automatically

**Proxy Support:**
Both layers support proxying via http/socks5 URLs. Can be set per-request, via
environment variables (HTTP_PROXY, HTTPS_PROXY, ALL_PROXY, NO_PROXY), or for
WebSockets connecting through Tor.

=== API / SYNTAX ===

---- HTTP Module (http.lua) ----

http.init()
  Initialize the HTTP module. Must be called once at startup. Creates worker
  thread channels and launches initial worker threads.

http.request(id, opts)
  Start an async HTTP request. Returns immediately (non-blocking).

  id:    string or number. You assign this; it's returned in the response.
  opts:  table with keys:
         url      - string, required, full URL
         method   - string, "GET" (default), "POST", "PUT", "DELETE", "PATCH", "HEAD"
         headers  - table, optional { "Content-Type": "application/json", ... }
         body     - string, optional request body
         proxy    - string, optional proxy URL:
                    "http://host:port"
                    "socks5://host:port"
                    "socks5://user:pass@host:port"

  Example:
    http.request("fetch-posts", {
      url = "https://api.example.com/posts",
      method = "GET",
      headers = { Accept = "application/json" }
    })

http.poll()
  Poll for completed responses. Call once per frame (in love.update).

  Returns:  array of response objects (may be empty)
            Each response is:
            { id, status, headers, body, error }
            - status: HTTP status code (0 if error)
            - headers: table { "content-type": "...", ... }
            - body: string response body
            - error: string if request failed (net error, timeout, etc.)

  Example:
    local responses = http.poll()
    for _, resp in ipairs(responses) do
      if resp.error then
        print("Request failed:", resp.error)
      else
        print("Status:", resp.status)
        print("Body:", resp.body)
      end
    end

---- WebSocket Module (network.lua) ----

network.init()
  Initialize the WebSocket network manager. Must be called once at startup.

network.connect(id, url, opts)
  Connect to a WebSocket server.

  id:    number, auto-assigned connection ID. JS and Lua both use this to refer
         to the connection.
  url:   string, ws:// or wss:// URL
  opts:  table, optional:
         proxy - string, socks5 proxy for tunneling (e.g., "127.0.0.1:9050" for Tor)
         reconnect - boolean, auto-reconnect on close (default: true)

  Example:
    network.connect(1, "ws://localhost:8000/chat")
    network.connect(2, "ws://hidden.onion/game", { proxy = "127.0.0.1:9050" })

  Emits: ws:open event when connected, ws:error on failure.

network.send(id, data)
  Send a message on an open connection.

  data:  string, the message to send.

  Example:
    network.send(1, "Hello, server!")

network.close(id, code, reason)
  Close a connection. May be called before it's open. Disables auto-reconnect.

  code:    number, optional WebSocket close code (default: 1000)
  reason:  string, optional close reason

  Emits: ws:close event when fully closed.

network.poll()
  Poll for events. Call once per frame.

  Returns:  array of event objects (may be empty)
            Each event is one of:
            { type = "ws:open", id = N }
            { type = "ws:message", id = N, data = "..." }
            { type = "ws:error", id = N, error = "..." }
            { type = "ws:close", id = N }

  Example:
    local events = network.poll()
    for _, evt in ipairs(events) do
      if evt.type == "ws:message" then
        print("Message from", evt.id, ":", evt.data)
      elseif evt.type == "ws:error" then
        print("Connection error:", evt.error)
      end
    end

network.listen(serverId, port, host)
  Start a WebSocket server. Listens for incoming connections.

  serverId: string, unique identifier for this server instance
  port:     number, port to listen on (e.g., 8000)
  host:     string, bind address (default: "127.0.0.1")

  Example:
    network.listen("game_server", 8000, "127.0.0.1")

  Emits: ws:server:ready event, then ws:peer:connect, ws:peer:message, ws:peer:disconnect
         Each connected client has a clientId (auto-assigned).

network.broadcast(serverId, data)
  Send a message to all connected clients on a server.

  serverId: string, the server ID
  data:     string, the message to broadcast

  Example:
    network.broadcast("game_server", json.encode({ x = 100, y = 200 }))

network.sendToClient(serverId, clientId, data)
  Send a message to a specific client on a server.

  serverId: string, the server ID
  clientId: number, the client ID (from ws:peer:connect event)
  data:     string, the message to send

  Example:
    network.sendToClient("game_server", 2, "You were hit!")

network.stopServer(serverId)
  Stop a server and disconnect all clients.

  Emits: ws:close for each client

network.destroy()
  Shut down all connections and servers. Call on app exit.

---- Server Events ----

When using network.listen(), poll events include:

  { type = "ws:server:ready", serverId = "...", port = 8000 }
    Server started and listening.

  { type = "ws:peer:connect", serverId = "...", clientId = N }
    New client connected (clientId assigned automatically).

  { type = "ws:peer:message", serverId = "...", clientId = N, data = "..." }
    Message from client N.

  { type = "ws:peer:disconnect", serverId = "...", clientId = N, code = 1000, reason = "" }
    Client N disconnected.

---- Proxy & SOCKS5 (socks5.lua) ----

socks5.connect(proxyHost, proxyPort, targetHost, targetPort, user, pass)
  Low-level: establish a TCP socket through a SOCKS5 proxy. Used internally by
  http.lua and network.lua. Supports RFC 1928 (no-auth) and RFC 1929 (user/pass).

  Returns: socket object (LuaSocket), or nil + error string.

  This is for advanced use. HTTP and WebSocket modules handle proxying automatically.

=== EXAMPLES ===

Example 1: Simple HTTP GET
---
local http = require("lua.http")
http.init()

function love.update(dt)
  http.request("get-json", {
    url = "https://api.github.com/users/octocat",
    method = "GET",
    headers = { Accept = "application/vnd.github.v3+json" }
  })

  local responses = http.poll()
  for _, resp in ipairs(responses) do
    if resp.id == "get-json" and resp.status == 200 then
      local data = require("lua.json").decode(resp.body)
      print("GitHub user:", data.name)
    end
  end
end
---
Platforms: love2d

Example 2: POST with JSON Body
---
local http = require("lua.http")
local json = require("lua.json")
http.init()

function love.update(dt)
  http.request("create-post", {
    url = "https://api.example.com/posts",
    method = "POST",
    headers = { ["Content-Type"] = "application/json" },
    body = json.encode({ title = "Hello", body = "World" })
  })

  local responses = http.poll()
  for _, resp in ipairs(responses) do
    if resp.error then
      print("Error:", resp.error)
    elseif resp.status >= 200 and resp.status < 300 then
      print("Post created:", resp.body)
    else
      print("HTTP error:", resp.status)
    end
  end
end
---
Platforms: love2d

Example 3: WebSocket Real-Time Chat
---
local network = require("lua.network")
network.init()

local connectionId = 1

function love.update(dt)
  -- Connect on first frame
  if not connected then
    network.connect(connectionId, "ws://localhost:8000/chat")
    connected = true
  end

  -- Poll for events
  local events = network.poll()
  for _, evt in ipairs(events) do
    if evt.id == connectionId then
      if evt.type == "ws:open" then
        print("Connected to chat")
        network.send(connectionId, "Hello chat!")
      elseif evt.type == "ws:message" then
        print("Received:", evt.data)
      elseif evt.type == "ws:error" then
        print("Connection error:", evt.error)
      elseif evt.type == "ws:close" then
        print("Disconnected")
      end
    end
  end
end

function love.mousereleased(x, y, button)
  if button == 1 then
    network.send(connectionId, "User clicked at " .. x .. ", " .. y)
  end
end
---
Platforms: love2d

Example 4: SOCKS5 Proxy (Tor)
---
local http = require("lua.http")
http.init()

-- Route HTTP request through Tor (SOCKS5 on port 9050)
http.request("tor-check", {
  url = "https://check.torproject.org/api/ip",
  proxy = "socks5://127.0.0.1:9050"
})

-- Or via environment variable
os.setenv("ALL_PROXY", "socks5://127.0.0.1:9050")
http.request("tor-request", {
  url = "https://example.com"
})
---
Platforms: love2d

Example 5: Multiplayer Game Server (Host)
---
local network = require("lua.network")
local json = require("lua.json")

local gameServer = "game"
local players = {}  -- id -> { x, y, name, score }

function love.load()
  network.init()
  network.listen(gameServer, 8000, "127.0.0.1")
  print("Game server listening on port 8000")
end

function love.update(dt)
  local events = network.poll()
  for _, evt in ipairs(events) do
    if evt.type == "ws:server:ready" then
      print("Server ready on port " .. evt.port)

    elseif evt.type == "ws:peer:connect" then
      print("Client " .. evt.clientId .. " joined")
      players[evt.clientId] = { x = 0, y = 0, name = "Player" .. evt.clientId, score = 0 }

    elseif evt.type == "ws:peer:message" then
      -- Parse player update: { x, y, action }
      local msg = json.decode(evt.data)
      if players[evt.clientId] then
        players[evt.clientId].x = msg.x or players[evt.clientId].x
        players[evt.clientId].y = msg.y or players[evt.clientId].y
        if msg.action == "collect" then
          players[evt.clientId].score = (players[evt.clientId].score or 0) + 10
        end
      end

    elseif evt.type == "ws:peer:disconnect" then
      print("Client " .. evt.clientId .. " left")
      players[evt.clientId] = nil
  end

  -- Broadcast game state every frame
  local state = { players = players, time = love.timer.getTime() }
  network.broadcast(gameServer, json.encode(state))
end
---
Platforms: love2d

Example 6: Multiplayer Game Client (Join)
---
local network = require("lua.network")
local json = require("lua.json")

local serverId = 1
local gameState = {}
local player = { x = 100, y = 100, name = "Me", score = 0 }

function love.load()
  network.init()

  -- Connect to game server on localhost:8000
  -- (In real scenario, use server's public IP or .onion address)
  network.connect(serverId, "ws://127.0.0.1:8000/game")
end

function love.update(dt)
  -- Handle movement
  local speed = 200
  if love.keyboard.isDown("up") then player.y = player.y - speed * dt end
  if love.keyboard.isDown("down") then player.y = player.y + speed * dt end
  if love.keyboard.isDown("left") then player.x = player.x - speed * dt end
  if love.keyboard.isDown("right") then player.x = player.x + speed * dt end

  -- Send player state to server
  network.send(serverId, json.encode({ x = player.x, y = player.y }))

  -- Receive game state
  local events = network.poll()
  for _, evt in ipairs(events) do
    if evt.type == "ws:open" then
      print("Connected to game server")

    elseif evt.type == "ws:message" then
      gameState = json.decode(evt.data)

    elseif evt.type == "ws:error" then
      print("Connection error:", evt.error)

    elseif evt.type == "ws:close" then
      print("Disconnected from server")
  end
end

function love.draw()
  -- Draw local player
  love.graphics.setColor(1, 1, 0)  -- Yellow
  love.graphics.circle("fill", player.x, player.y, 10)
  love.graphics.print(player.name, player.x - 30, player.y - 20)

  -- Draw other players
  love.graphics.setColor(1, 0, 1)  -- Magenta
  if gameState.players then
    for id, p in pairs(gameState.players) do
      if id ~= serverId and p.x then
        love.graphics.circle("fill", p.x, p.y, 10)
        love.graphics.print(p.name .. " (" .. (p.score or 0) .. ")", p.x - 30, p.y - 20)
      end
    end
  end
end
---
Platforms: love2d

=== CRITICAL RULES ===

**Initialization:**
- Always call http.init() and network.init() once at startup (love.load)
- Always call network.destroy() on app exit (love.quit)

**Polling:**
- Always poll for responses/events each frame (http.poll(), network.poll())
- If you don't poll, events queue up and never get processed
- Call in love.update() once per frame

**WebSocket (Client):**
- Use unique IDs (1, 2, 3...) for concurrent connections
- Each connection has its own auto-reconnect behavior
- WebSocket auto-reconnect uses exponential backoff (starts at 1s, caps at 60s)

**WebSocket Server (Host):**
- One server ID per server (e.g., "game", "chat", "relay")
- Each connected client gets a unique clientId (auto-assigned 1, 2, 3...)
- server.listen() can be called multiple times for different servers
- Call network.stopServer() to stop a server cleanly

**Multiplayer-Specific:**
- Host player runs network.listen() (server)
- Client players run network.connect() (client)
- Send game state regularly (e.g., every 50ms, not every frame if 60 FPS)
- Use JSON for serialization (require("lua.json"))
- Test with 2+ players before release

**HTTP:**
- Use unique IDs for concurrent HTTP requests
- HTTP requests timeout after 15 seconds
- SOCKS5 connections timeout after 15 seconds
- Proxies are optional; omit for direct connections

**Tor Integration:**
- For Tor hidden services, call tor.lua functions before network.listen()
- Ensure Tor is running on port 9050 (or auto-detected port)
- .onion addresses are only available after Tor bootstrap (5-30s)

=== PERFORMANCE & OPTIMIZATION ===

**HTTP:**
- Uses love.thread (CPU-bound): each request reserves one worker thread
- Max 4 concurrent requests by default
- For high throughput, batch requests or increase maxWorkers in http.lua
- Requests timeout after 15s to avoid hanging threads

**WebSocket (Client):**
- Lightweight (one pure Lua coroutine per connection)
- Auto-reconnect uses exponential-backoff; doesn't block
- Can maintain 10-100+ simultaneous connections without CPU overhead
- Typical CPU usage: <1% per connection

**WebSocket Server:**
- One server can handle 10-1000+ simultaneous clients (depends on game logic)
- Each client connection gets a unique ID
- Broadcasting scales with client count (O(n) for N clients)
- CPU usage: minimal for idle servers; depends on message rate

**Multiplayer Optimization:**

1. **Update Rate** — Don't send every frame
   Bad:  Send player position 60 times/second (network updates block on each send)
   Good: Send player position 10-20 times/second (batch with game loop)

2. **Data Compression**
   Bad:  { x = 123.456, y = 789.012, hp = 100, stamina = 50, ... }
   Good: { x = 123, y = 789 }  (only changed fields, quantize floats)

3. **Broadcast Batching**
   Bad:  Broadcast player state immediately on any change
   Good: Accumulate changes, broadcast once per 50ms tick

4. **Connection Pooling**
   Reuse connections; don't create/destroy frequently

**Bandwidth (Typical):**
- Player position update: 20 bytes
- Chat message: 100-200 bytes
- Full game state sync: 100-500 bytes
- For 4 players at 20 Hz: ~3.2 KB/sec (0.1 KB per update * 4 players * 20 Hz)

**Latency Budget:**
- Network round-trip: 50-200ms (typical internet)
- Tor adds: +50-100ms additional
- Game should tolerate 100-300ms latency for smooth multiplayer

=== SEE ALSO ===
- tor.txt - Tor hidden services for multiplayer, direct .onion connections
- lua-runtime.txt - http.lua, network.lua, websocket.lua, socks5.lua modules
- 06-hooks/useeffect.txt - Using hooks to manage network requests
- https://developer.mozilla.org/en-US/docs/Web/API/WebSocket - WebSocket spec
- https://www.torproject.org/docs/onion-services/ - Tor hidden services guide
