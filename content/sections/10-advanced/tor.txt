=== METADATA ===
title: Tor Hidden Services & Multiplayer Networking
description: Use Tor hidden services to host multiplayer games and apps without port forwarding, firewall config, or complex infrastructure. Direct peer connections via .onion addresses.
category: Advanced
platforms: love2d
keywords: tor, hidden-service, onion, socks5, proxy, privacy, anonymity, multiplayer, p2p, networking
related: networking, lua-runtime
difficulty: advanced

=== OVERVIEW ===

**THE SIMPLEST MULTIPLAYER: SHARE A .ONION ADDRESS**

Tor hidden services let you host a multiplayer game without port forwarding, firewall
rules, or cloud servers. Your app generates a .onion address automatically. Share it
with friends, they connect directly. That's it.

iLoveReact includes Tor integration for anonymous multiplayer, direct peer connections,
and hosting hidden services. The tor.lua module auto-starts a Tor subprocess, configures
hidden service forwarding, polls for bootstrap completion, and provides the .onion
address. HTTP and WebSocket connections can be routed through Tor via SOCKS5 proxies.

Tor setup is opt-in: call tor.start({ hsPort = 8080 }) when the app loads. If not
enabled, Tor is not started. Hidden service bootstrap takes 5-30s; poll tor.getHostname()
each frame until it returns your .onion address.

**Why Tor for Multiplayer?**

- No port forwarding: Tor handles NAT/firewall traversal automatically
- No DNS: Pure TCP connections, no third-party servers needed
- No infrastructure: Works peer-to-peer between players
- Built-in privacy: Tor anonymizes traffic if desired
- Works everywhere: Works over residential ISPs, coffee shop WiFi, tethering, VPNs
- One address forever: Your .onion address stays the same across sessions

=== COMMON PATTERNS ===

**Pattern 1: Host a Multiplayer Server (Server-side)**

1. Player A starts the game with Tor enabled
2. Server listens on a local WebSocket port (e.g., ws://127.0.0.1:8000/game)
3. Tor forwards .onion:80 â†’ localhost:8000 automatically
4. Player A sees: "Server ready: abc123def456.onion"
5. Player A shares that address with Player B

**Pattern 2: Join a Game (Client-side)**

1. Player B gets the .onion address from Player A (via chat, Discord, etc.)
2. Player B's app connects: network.connect(1, "ws://abc123def456.onion/game")
3. Tor SOCKS5 tunnel on localhost:9050 automatically handles .onion resolution
4. Connection established: both players see each other's moves in real-time

**Pattern 3: Hybrid (Server + Client)**

Many games let players host locally and connect to others' servers. One player
hosts (exposes .onion), others join (connect to .onion). No central server needed.

**Pattern 4: Anonymous HTTP Requests (Cheating Prevention)**

For anti-cheat or validation, route requests through Tor to hide your real IP:

  http.request("validate", {
    url = "https://yourserver.com/api/verify",
    proxy = "socks5://127.0.0.1:9050"
  })

**Pattern 5: Direct Connection (No Hidden Service)**

If you only want direct peer connections, skip Tor. Use network.connect() with
IP addresses or regular hostnames. Tor is optional â€” use it when you need:
- Automatic NAT traversal
- Privacy / anonymity
- One-time addresses you can share
- No infrastructure costs

=== API / SYNTAX ===

---- Tor Module (tor.lua) ----

tor.start(config)
  Start a Tor subprocess with hidden service configuration.

  config: table with keys:
          hsPort   - integer, required, port to forward hidden service traffic to
                     (e.g., hsPort = 8080 means Tor will forward port 80 of your
                     .onion address to localhost:8080)
          binPath  - string, optional path to Tor binary (defaults to "tor" in PATH)
                     If not found, will attempt to use system Tor at
                     /usr/bin/tor or /usr/local/bin/tor

  Returns: nothing. Use tor.getHostname() to poll for the .onion address.

  Example:
    tor.start({ hsPort = 8080 })

tor.getHostname()
  Poll for the hidden service hostname. Blocks until Tor has bootstrapped and
  the .onion address is available (typically 5-30 seconds). After bootstrap,
  returns immediately.

  Returns: string ".onion address" (e.g., "3g2upl4pq6kufc4m.onion")
           or nil if not yet available.

  Example:
    local hostname = tor.getHostname()
    if hostname then
      print("Hidden service ready at:", hostname)
    end

tor.stop()
  Stop the Tor subprocess. Gracefully shuts down via SIGTERM.

  Call this when exiting the app to clean up.

  Example:
    function love.quit()
      tor.stop()
      return false
    end

---- Proxy Integration (via http.lua and network.lua) ----

Both http.lua and network.lua accept a proxy parameter:

  http.request("id", { url = "...", proxy = "socks5://127.0.0.1:9050" })
  network.connect(1, "ws://...", { proxy = "127.0.0.1:9050" })

Supported proxy formats:
  - "socks5://host:port"
  - "socks5://user:pass@host:port"
  - "http://host:port" (HTTP proxy, for http.lua only)

=== EXAMPLES ===

Example 1: Multiplayer Server (Host a Game)
---
local tor = require("lua.tor")
local network = require("lua.network")

local players = {}  -- id -> { x, y, name }
local serverId = "game_server"
local gameStateVersion = 0

function love.load()
  -- Start Tor hidden service
  tor.start({ hsPort = 8000 })

  -- Start listening for player connections
  network.init()
  network.listen(serverId, 8000, "127.0.0.1")
end

function love.update(dt)
  -- Poll for Tor bootstrap
  local hostname = tor.getHostname()
  if hostname and not serverReady then
    print("ðŸŽ® Server ready!")
    print("Share with friends: " .. hostname)
    serverReady = true
  end

  -- Handle incoming connections and messages
  local events = network.poll()
  for _, evt in ipairs(events) do
    if evt.type == "ws:peer:connect" then
      print("Player " .. evt.clientId .. " joined")
      players[evt.clientId] = { x = 0, y = 0, name = "Player" .. evt.clientId }

    elseif evt.type == "ws:peer:message" then
      -- Parse movement: { x, y, name }
      local json = require("lua.json")
      local msg = json.decode(evt.data)
      if players[evt.clientId] then
        players[evt.clientId].x = msg.x
        players[evt.clientId].y = msg.y
      end

    elseif evt.type == "ws:peer:disconnect" then
      print("Player " .. evt.clientId .. " left")
      players[evt.clientId] = nil
  end

  -- Broadcast game state every frame
  gameStateVersion = gameStateVersion + 1
  local state = {
    version = gameStateVersion,
    players = players,
  }
  network.broadcast(serverId, require("lua.json").encode(state))
end

function love.quit()
  tor.stop()
  return false
end
---
Platforms: love2d

Example 2: Multiplayer Client (Join a Game)
---
local network = require("lua.network")

local connectionId = 1
local players = {}
local localPlayer = { x = 100, y = 100, name = "Me" }
local serverAddress = "abc123def456789.onion"  -- Shared by host

function love.load()
  network.init()

  -- Connect to host's .onion address
  -- Tor SOCKS5 on 9050 handles the .onion tunnel automatically
  network.connect(connectionId, "ws://" .. serverAddress .. "/game")
end

function love.update(dt)
  -- Handle arrow keys / movement
  if love.keyboard.isDown("up") then localPlayer.y = localPlayer.y - 200 * dt end
  if love.keyboard.isDown("down") then localPlayer.y = localPlayer.y + 200 * dt end
  if love.keyboard.isDown("left") then localPlayer.x = localPlayer.x - 200 * dt end
  if love.keyboard.isDown("right") then localPlayer.x = localPlayer.x + 200 * dt end

  -- Send my position to server
  local json = require("lua.json")
  network.send(connectionId, json.encode(localPlayer))

  -- Receive game state
  local events = network.poll()
  for _, evt in ipairs(events) do
    if evt.type == "ws:open" then
      print("Connected to " .. serverAddress)

    elseif evt.type == "ws:message" then
      local state = json.decode(evt.data)
      players = state.players
      -- Render all players on screen

    elseif evt.type == "ws:error" then
      print("Connection error:", evt.error)

    elseif evt.type == "ws:close" then
      print("Disconnected from server")
  end
end

function love.draw()
  -- Draw local player
  love.graphics.setColor(1, 1, 0)  -- Yellow
  love.graphics.circle("fill", localPlayer.x, localPlayer.y, 10)

  -- Draw other players
  love.graphics.setColor(1, 0, 1)  -- Magenta
  for id, player in pairs(players) do
    if player.x then
      love.graphics.circle("fill", player.x, player.y, 10)
    end
  end
end
---
Platforms: love2d

Example 3: Direct Peer Connection (No Hidden Service)
---
-- For simple testing: one player hosts on a known IP, the other connects.
-- No Tor needed.

local network = require("lua.network")

function love.load()
  network.init()

  -- Player A (Host): listen locally
  network.listen("host", 8000, "127.0.0.1")

  -- Player B (Client): connect to Player A's IP
  -- (In practice, Player A would share their external IP or you'd use a matchmaker)
  network.connect(1, "ws://192.168.1.50:8000/game")
end
---
Platforms: love2d

Example 4: Host Two Apps on Same Machine
---
-- Scenario: You want to run two games on the same laptop via Tor
-- Each gets its own .onion address and SOCKS5 port

local tor1 = require("lua.tor")
local tor2 = require("lua.tor")

function love.load()
  -- App 1: Tor hidden service on port 8001
  tor1.start({ hsPort = 8001 })

  -- App 2: Tor hidden service on port 8002
  tor2.start({ hsPort = 8002 })

  -- Each app gets a unique .onion address and SOCKS5 port
  -- tor1.getHostname() â†’ abc123...onion (port 8001)
  -- tor2.getHostname() â†’ def456...onion (port 8002)
end
---
Platforms: love2d

Example 5: Anonymous Multiplayer (Obfuscate Player IP)
---
-- Route all traffic through Tor so the game server can't see your IP
-- Useful for privacy-focused games or anti-cheat

local network = require("lua.network")
local tor = require("lua.tor")

function love.load()
  network.init()

  -- Ensure Tor is running (auto-starts if tor.lua is required)
  -- Tor SOCKS5 on 9050

  -- Connect through Tor SOCKS5 proxy
  network.connect(1, "ws://gameserver.example.com/play", {
    proxy = "127.0.0.1:9050"  -- Route through Tor
  })
end
---
Platforms: love2d

=== CRITICAL RULES ===

**Multiplayer-Specific:**
- Always show the .onion address to the player after bootstrap (poll getHostname() each frame)
- Share the .onion address out-of-band (Discord, chat, etc.). It's permanent for this Tor instance.
- Multiple players connecting to the same host all see the same game state
- Each connected player has a unique client ID (1, 2, 3, ...) on the server
- Tor bootstrap adds 5-30s startup latency; plan for this in your UX

**Tor Lifecycle:**
- Tor startup is async (5-30s). Always poll getHostname() each frame until it returns.
- Hidden service ports are logical; use hsPort to map to your actual server port.
- Tor subprocess requires: Tor binary in PATH, or explicit binPath in config.
- On exit, always call tor.stop() to gracefully shutdown Tor.
- SOCKS5 default port is 9050 (Tor). Do NOT assume 1080.
- .onion addresses are long (16+ chars v3) and contain only lowercase a-z, 0-9.
- Tor bootstrap can fail (network down, port conflict). Check getHostname() return.
- Each Tor instance automatically finds an open SOCKS5 port (9050, 9051, 9052, ...)
- Multiple Tor instances can coexist; each gets its own .onion and SOCKS5 port

=== PERFORMANCE & LATENCY ===

**Startup:**
- Tor bootstrap: 5-30s (first connection only)
- Hidden service hostname available: ~5-30s after start
- SOCKS5 connection handshake: ~200-500ms (includes Tor circuit building)
- WebSocket upgrade: <100ms

**Active Connection:**
- Tor adds ~50-100ms latency per message (typical)
- Message bandwidth: limited by Tor network, not iLoveReact
- Player state updates: batch & transmit at your game's update rate (e.g., 60 FPS)
- No bandwidth overhead from Tor itself; data goes through at normal speeds

**Optimization for Multiplayer:**

1. **Compress game state** â€” send only changed fields, not full state each frame
2. **Update rate** â€” don't send player position every frame; use 10-20 Hz updates
3. **Differential updates** â€” only broadcast when player moves > threshold pixels
4. **Batch messages** â€” send multiple updates in one WebSocket frame

Example:
  -- Bad: sends 60 times per second
  network.send(connectionId, json.encode(player))  -- in love.update()

  -- Good: sends 20 times per second
  if love.timer.getTime() % (1/20) < dt then
    network.send(connectionId, json.encode({
      x = player.x,
      y = player.y,
      -- omit timestamp, health, etc if unchanged
    }))
  end

**CPU Usage:**
- Tor subprocess: ~10-30 MB RAM, <1% CPU when idle
- WebSocket polling: <1% CPU for typical games
- SOCKS5 tunneling: <1% CPU per tunnel
- No garbage collection spikes from networking

**Bandwidth (Typical):**
- .onion address broadcast: 16 bytes/message
- Player position update: 20-50 bytes/update
- Game state sync: 100-500 bytes/sync
- Chat message: 100-200 bytes

For a 4-player game at 20 Hz: ~80 KB/s total (all players combined)

=== ALTERNATIVES & TRADE-OFFS ===

**When to Use Tor Hidden Services:**
- Peer-to-peer multiplayer (2-8 players)
- No server infrastructure costs
- No port forwarding / firewall headaches
- Privacy is a feature (obfuscate player IPs)
- One-time event games (jam, competition, LAN substitute)
- Community games (share .onion address with friends)

**When NOT to Use Tor:**
- Large player counts (100+ players) â€” use a dedicated server instead
- Latency-critical games (fighting games, rhythm games) â€” 50-100ms+ latency too high
- Video streaming â€” Tor bandwidth limited to ~1-5 Mbps per circuit
- DDoS-vulnerable â€” Tor can mitigate some attacks but not designed for protection
- LAN games â€” just use direct IP addresses on the local network
- Games needing global matchmaking â€” use a central server for discovery

**Alternatives:**
1. **Direct IP connections** (no Tor) â€” network.connect(1, "ws://192.168.1.50:8000")
   - Pro: Lowest latency, works on LAN, no Tor dependency
   - Con: Need to know IP, no NAT traversal, firewall rules needed

2. **Central server** â€” host on a cloud provider (AWS, DigitalOcean, etc.)
   - Pro: Scalable, low latency, can relay between players
   - Con: Monthly costs, server management overhead

3. **Hybrid** â€” use Tor for discovery, relay only game state through central server
   - Pro: Automatic peer discovery, lower latency on state updates
   - Con: More complex architecture

**Tor is Best For:** Casual multiplayer where setup time doesn't matter and infrastructure cost is zero.

=== SETUP CHECKLIST ===

**For Development:**
- [ ] Install Tor: `apt install tor` (Linux), `brew install tor` (macOS)
- [ ] Test: `tor --version` should print version
- [ ] Write server code (network.listen() + game logic)
- [ ] Write client code (network.connect() + game logic)
- [ ] Run server app, get .onion address
- [ ] Run client app, connect to that address
- [ ] Test game state synchronization

**For Production (dist:love):**
- [ ] Test build includes Tor binary or requires system Tor
- [ ] Provide setup instructions for end-users (Tor installation)
- [ ] Show .onion address in-game (on UI, in console, etc.)
- [ ] Provide out-of-band sharing method (Discord, email, chat, etc.)
- [ ] Test on target machines (different networks, ISPs, firewalls)

**Troubleshooting:**
- Tor won't start? Check `~/.cache/ilovereact-tor/tor.log` for errors
- Connection hangs? Tor bootstrap can take 30s; be patient
- getHostname() returns nil after 60s? Tor may have failed; check logs
- SOCKS5 connection timeout? Network issue or Tor circuit too slow
- Low bandwidth? Normal for Tor; batch updates and compress data

=== PLATFORM NOTES ===

**Love2D:**
  Tor must be available as a system binary (apt install tor, brew install tor, etc.).
  If Tor is not installed, tor.start() will fail silently and getHostname() will
  return nil indefinitely. Consider including a bundled Tor binary in dist:love
  builds for production.

**Terminal / Neovim / ComputerCraft / AwesomeWM:**
  Networking support (http.lua, network.lua) is Love2D-specific for now. Direct
  IP connections may be available on other targets in the future.

=== SEE ALSO ===
- networking.txt - HTTP and WebSocket proxying, direct connections
- lua-runtime.txt - tor.lua, socks5.lua, network.lua internals
- https://www.torproject.org/ - Tor project
- https://www.torproject.org/docs/ - Tor documentation
- https://www.torproject.org/docs/onion-services/ - Hidden services guide
